## 基本语法

### 数据类型

1. 整型
    - int 4bytes
    - short 2bytes
    - long 8bytes
    - byte 1bytes

2. 浮点
    - float 4bytes
    - double 8bytes
    - 特殊值
    	- 正无穷大 Double.POSITIVE_INFINITY
    	- 负无穷大 Double.NEGATIVE_INFINITY
    	- NaN Double.NaN
    
3. char：Unicode编码  
4. Boolean：不能直接跟整型互相转换  

### 变量
1. 变量：最好逐一声明每个变量
2. 常量：使用final关键字来定义，const是Java保留的关键字，但目前并没有使用

### 运算符
......

### 字符串
Unicode字符序列，String类
1. 子串：substring方法
2. 拼接：+
3. 不可变字符串：Java的字符串相当于C/C++里面的char*，不能修改，但能重新赋值
4. 检测字符串是否相等：equal方法，不能使用==来进行判断（C++的string可以）
5. 空串与Null串：空串就是长度为0的串，Null串就是没有对象与之关联的字符串
6. 代码单元与代码点
7. 字符串API

### 输入输出
1. 读取输入：`Scanner in = new Scanner(System.in);`
2. 格式化输出：`System.printf();`跟C/C++语法类似，其中有个输出日期要注意一下
3. 文件输入输出
    - 从文件读取：`Scanner(File f)`，例`Scanner in = new Scanner(Path.get("some.txt"));`
    - 输出到文件：`PrintWriter(String fileName)`  

    上面只是文件输入输出的其中一种方法，还有好几种输入输出的方法，而且要注意输入输出最后要关闭。
    
### 流程控制
1. 条件语句
2. 循环
    - while
    - do while
    - for
3. 多重选择
4. 中断流程控制
    - break：可以break多层，带标签
        ```java
        label:
        {
            ...
            if(condition)
                break label; // exit block
            ...
        }
        ```
    - continue：也跟break一样，可以带标签跳转
    
### 大数值
BigInteger任意精度的整数，BigDecimal任意精度的浮点数，用valueOf()来初始化
1. add()
2. subtract()
3. multiply()
4. divide()
5. pow()
6. modPow()：浮点数没有该方法
7. compareTo()：小于返回负数，大于返回正数，等于返回0

### 数组
1. for each循环 `for (variable : collection) statement`
2. 数组初始化以及匿名数组
3. 数组拷贝，直接=是指向同一个数组，要使用`Array.copyOf(array, length)`
4. 命令行参数，main中的参数
5. 数组排序，`Array.sort(array)`
6. 多维数组
7. 不规则数组

## 对象和类

### 面向对象概述
1. 类
2. 对象
3. 类间关系

### 使用预定义类
1. 对象与对象变量：对象变量只是引用对象（内存空间），直接赋值指向的是同一个对象，需要使用clone方法才能获得对象的完整拷贝
2. Date类，GregorianCalendar类，Calendar类等常用日期类
3. 更改器方法，访问器方法
4. 应用GregorianCalendar类的程序，显示当月日期

### 使用自定义类
1. 使用Employee类
2. Java的所有对象都是在堆里面构造的，构造器总是伴随着new一起使用
3. 隐式参数（this）与显式参数
4. 不要直接返回一个对象，要用clone方法，返回他的一个副本
5. 基于类的访问权限，Employee类的方法可以访问Employee类的任何一个对象的私有域
6. 私有方法
7. final实例域，例如：`final GregorianCalendar c = new GregorianCalendar();`，不能修改c引用其他对象，但是可以修改c引用的对象的值，这里的c相当于C++中的指针常量

### 静态域与静态方法
1. 静态常量
2. 静态方法
3. 工厂方法
4. main方法

### 方法参数
1. 方法参数有两种类型：基本数据类型和对象引用
2. 方法参数的使用情况
    - 方法不能修改基本类型的参数，即不能`swap(base a, base b) { 交换a，b的值 }`
    - 方法可以改变对象参数的状态，即可以`add(object) { ++object.a; }`
    - 方法不能让对象参数引用一个新的对象，即不能`swap(object obj1, object obj2) { 交换两个对象的指向 }`

### 对象构造
1. 重载
2. 默认域初始化：没有显式赋值的情况下，系统会赋默认值，数值为0，布尔为false，对象引用为null
3. 无参数的构造器
    - 没有编写构造器时，系统会有提供无参数的构造器，赋值如2所示
    - 有带参数的构造器时，但在构造对象时不提供参数就会被视为不合法
    - 仅当类没有提供任何构造器时，系统才会提供一个默认的构造器
4. 显式域初始化，在执行构造器前初始化
5. 参数名
6. 调用另一个构造器，`this()`
7. 初始化块
8. 对象析构与finalize方法
    - Java有自动的垃圾回收器，不需要人工回收内存，所以不支持析构器
    - 使用了内存之外的其他资源如文件等，需要手动关闭回收，可以为类添加一个finalize方法，该方法将在垃圾回收器清除对象前调用

### 包
1. 类的导入，`import java.util.*`
2. 静态导入，`import static java.lang.System.*`就可以直接使用`out.println();`
3. 将类放入包中，`package xxx`
4. 包作用域（包中的类，方法或变量）
    - private，只能被定义他们的类使用
    - public，可以被任意的类使用
    - 没有指定，可以被同一个包中的所有方法访问

### 类路径

### 文档注释
javadoc可以由源文件生成一个HTML文档  
1. 注释的插入，javadoc从以下几个特性中抽取信息：
    - 包
    - 公有类和接口
    - 公有的和受保护的构造器及方法
    - 公有的合受保护的域
2. 类注释：放在import之后，类定义之前
3. 方法注释
    - `@param`参数
    - `@return`返回
    - `@throws`异常
4. 域注释
    - `@author`作者姓名
    - `@version`版本
    - `@since`始于
    - `@deprecated`方法或xx不再使用，给出取代的建议
    - `@see`引用
5. 通用注释
6. 包与概述注释
7. 注释的抽取

### 类设计技巧
1. 一定要保证数据私有
2. 一定要对数据初始化
3. 不要在类中使用过多的基本类型，即用其他的类代替多个相关的基本类型的使用
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解
6. 类名和方法要能体现他们的职责

## 继承

### 类、超类和子类
Java中用关键字extends代替了c++中的冒号（:），而且在Java中所有的继承都是公有继承
1. 继承层次，继承不限于一个层次，Java中的多继承由接口来实现
2. 多态："is-a"规则，可以用超类变量引用任何一个子类的对象，例如可以把一个子类的对象赋给超类变量
3. 动态绑定
    - 编译器查看对象声明的类型和方法名
    - 接下来，编译器将查看调用方法时提供的参数类型
    - 如果是private, static, final方法，静态绑定
    - 当程序运行，并且采用动态绑定，虚拟机一定调用所引用对象的实际类型最合适的那个类的方法。
4. 阻止继承：final类和方法，不允许扩展
5. 强制类型转换：`(type) variable`
    - 不允许在继承链上进行向下的类型转换，用`instanceof`运算符判断是否能转换
6. 抽象类
    - 包含抽象方法的类本身要声明成抽象的，但抽象类里面可以有具体数据和方法
    - 扩展抽象类，一种可以继续抽象，另一种是定义全部抽象方法
    - 类就算不含抽象方法，也可以定义为抽象类
7. 受保护访问
    - 仅对本类可见——private
    - 对所有类可见——public
    - 对本包和所有子类可见——protected
    - 对本包可见——默认，不需要修饰符

### Object：所有类的超类
Java中只有基本类型不是对象，其他所有数组类型都是扩展于Object类
1. equals方法，需要自己编写
2. 相等测试与继承  
    Java语言规范要求equals具有下面的特性
    - 自反性，x.equals(x)应该返回true
    - 对称性，x.equals(y)返回true，y.equals(x)也应该返回true
    - 传递性，x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true
    - 一致性，如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果
    - 对于x非空，x.equals(null)应该返回false
3. hashCode方法：定义要与equals相同
4. toString方法

### 泛型数组列表
`ArrayList<T>`  
使用get和set访问，而不用[]

### 对象包装器与自动装箱
所有基本类型都有一个与之对应的类，可以把基本类型转换为对象

### 参数数量可变的方法
...代表参数可变

### 枚举类
都是Enum类的子类

### 反射*
1. Class类
2. 捕获异常
3. 利用反射分析的能力
4. 在运行时使用反射分析对象
5. 使用反射编写泛型数组代码
6. 调用任意方法

### 继承设计的技巧
1. 将公共操作和域放在超类。
2. 不要使用受保护的域。
3. 使用继承实现is-a关系。
4. 除非所有继承的方法都有意义，否则不要使用继承。
5. 在覆盖方法时，不要改变预期的行为。
6. 使用多态，而非类型信息。不要过多地使用反射。

## 接口与内部类

### 接口
关键字`implements`  
1. 接口的特性
    - 接口不是类，不能用new实例化一个接口，但是可以声明接口的变量
    - 接口可以被继承，扩展
    - 接口中可以包含常量
    - 一个类可以实现多个接口
2. 接口与抽象类  
    接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性

### 对象克隆
- 直接用=赋值，引用同一个对象
- 浅拷贝，用简单的clone方法，如果对象中包含了子对象的引用，结果会使两个域引用同一个子对象
- 深拷贝
    - 实现Cloneable接口
    - 使用public访问修饰符重新定义clone方法

### 接口与回调*

### 内部类
1. 内部类访问对象状态
2. 内部类特殊语法规则
3. 内部类是否有用，必要和安全
4. 局部内部类：定义在一个方法中的内部类，作用域限定在声明这个局部类的块中，好处是对外部世界完全隐藏
5. 由外部方法访问final变量
6. 匿名内部类
7. 静态内部类

### 代理

## 异常、断言、日志和调试

### 处理错误
1. 异常分类
2. 声明已检查异常
3. 如何抛出异常
4. 创建异常类

### 捕获异常
1. 捕获多个异常
2. 再次抛出异常与异常链
3. finally子句
4. 带资源的try语句
5. 分析堆栈跟踪元素

### 使用异常机制的技巧
1. 异常处理不能代替简单的测试
2. 不要过分细化异常
3. 利用异常层次结构
4. 不要压制异常
5. 早抛出，晚捕获

### 使用断言

### 记录日志

### 调试技巧

## 多线程

### 线程的生命周期以及五种基本状态
1. 新建状态（new）
2. 就绪状态（runnable）：调用了start()方法
3. 运行状态（run）
4. 阻塞状态（blocked）
    - 等待阻塞
    - 同步阻塞
    - 其他阻塞
5. 死亡状态（dead）

### 多线程的创建及启动
1. 继承Thread类，重写该类的run()方法
2. 实现Runnable接口，并重写该接口的run()方法
3. 使用Callable和Future接口创建线程

### Java多线程的就绪、运行和死亡状态
- 就绪->运行：线程得到处理器资源
- 运行->就绪：线程主动调用yield()方法或在运行过程中失去处理器资源
- 就绪->死亡：执行完毕或者发生了异常

### 多线程的阻塞状态与线程控制
1. join()：让主线程等待子线程结束后才能继续运行
2. sleep()：让当前的正在执行的线程暂停指定的时间，并进入阻塞状态
3. 后台线程
    - 后台线程主要是为其他线程提供服务的
    - 前台线程都死亡，后台线程自动死亡
    - 调用Thread对象的`setDaemon(true)`方法可以把线程设置为后台线程
4. 线程优先级
    - 设置优先级`setPriority(int priorityLevel)`，priorityLevel范围1~10，常用静态值有：
        - MAX_PRIORITY 10
        - MIN_PRIORITY 1
        - NORM_PRIORITY 5
    - 获取优先级`getPriority()`
5. yield()：让线程从运行状态变成就绪状态，并从就绪队列中取一条优先级比此线程高的线程运行

## Java与HTTP

### HTTP请求
1. 请求行
    - GET 
    - HEAD 用于获取报头
    - POST
    - PUT*
    - DELETE*
    - CONNECT*
    - OPTIONS*
    - TRACE*
2. 请求头部，常用消息头：
    - accept：支持的数据类型
    - Accept-Charset：支持哪种字符集
    - Accept-Encoding：支持的压缩环境
    - Accept-Language：语言环境
    - Host：访问哪台主机
    - If-Modified-Since：缓存数据的时间
    - Referer：防盗链
    - Connection：断开连接还是保持连接
3. 请求数据

### Java数据流
1. InputStream：所有字节输入流的超类
2. InputStreamReader：字节流与字符流间的桥梁，能将字节流输出为字符流，并能指定字符集
3. BufferedReader：提供通用的缓冲方式文本读取，从字符输入流中读取文本等，高效读取

在读取网络数据流时，可以先通过InputStream获取字节流（获取的数据是数字形式，每个数字都是一个字节`60 33 68 79...`），InputStreamReader将字节流转化成字符流（指定字符集等），BufferedReader将字符流以缓存形式输出的方式来快速获取网络数据流。