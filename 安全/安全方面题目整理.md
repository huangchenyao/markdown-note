[TOC]
## 安全
### Web应用安全
> Web安全主要分为客户端脚本安全和服务器端应用安全。  
> 客户端脚本安全主要包括：浏览器安全、XSS、CSRF、ClickJacking、HTML5安全  
> 服务器端应用安全主要包括：注入攻击、文件上传漏洞、认证与会话管理、访问控制、加密算法与随机数、Web框架安全、应用层拒绝服务攻击、PHP安全、Web Server配置安全。  

#### 一个Web应用的Linux被入侵，需要如何排查原因，请描述你的排查思路。  
此题考查的是对入侵回溯的排查经验。   
首先需要对被入侵Linux主机的HTTP流量日志进行攻击识别，通过已有的漏洞库规则进行直接数据匹配。  
其次需要排除被入侵的Linux主机使用的第三方应用程序框架及服务/应用端口是否存在弱口令（如phpMyAdmin默认的root/root）或者远程代码执行等直接获取服务器权限的漏洞，目录是否存在敏感信息漏洞等。  
最后通过入侵原因重放入侵者的整个入侵过程，通过规则/经验排查主机是否存在其他后门/漏洞文件。如使用Linux的grep/find命令直接搜索可疑代码/漏洞后门。  

#### 请描述OAuth等认证授权协议的主要流程。  
本题考查OAuth认证授权的主要流程。  
OAuth的认证与授权过程中涉及的三方包括：  
**服务商：**用户使用服务的提供方，一般用来存储消息、照片、视频、联系人、文件等（比如推特、微博等）。  
**用户：**服务商的用户。  
**第三方：**通常是网站，该网站想要访问用户存储在服务商那里的信息。比如某个提供照片打印服务的网站，用户想在这里打印自己存在服务商那里的网络相册。在认证过程之前，第三方需要先向服务商申请第三方的唯一标识。  
OAuth认证和授权的过程如下：  
1. 用户访问第三方网站，想对存放在服务商那里的某些资源进行操作。  
2. 第三方网站向服务商请求一个临时令牌。  
3. 服务商验证第三方网站的身份后，授予一个临时令牌。  
4. 第三方网站获得临时令牌后，将用户导向服务商的授权页面请求用户授权，然后这个过程中将临时令牌和第三方网站的返回地址发送给服务商。  
5. 用户在服务商的授权页面上输入自己的用户名和密码，授权第三方网站访问相应的资源。  
6. 授权成功后，服务商将用户导向第三方网站的返回地址。  
7. 第三方网站根据临时令牌从服务商那里获取访问令牌。  
8. 服务商根据令牌和用户的授权情况授予第三方网站访问令牌。  
9. 第三方网站使用获取到的访问令牌访问存放在服务商这里的对应资源。  

#### 下面这段PHP代码安全吗？如果有问题，请修正。
```php
$user = $_GET['user'];
$pass = $_GET['pass'];
if (!checkLogin($user, $pass)) {
	echo "<script>window.history.back();</script>";
}

echo "welcome xxxx";
```
此题考查逻辑漏洞。上述PHP代码为一个简单的登录验证功能，传入user和pass参数，进入checkLogin()函数，代码的本意是当用户名和密码错误时，checkLogin()函数返回False，然后跳转回登录页面，而当用户名密码正确时，输出"welcome xxxx"。  
产生漏洞的原因在于，if判断逻辑内echo "<script>window.history.back();</script>"这行代码执行完毕后，并没有结束执行流程，导致if外面的代码仍会被顺序执行，登录验证并没有起到作用。  
正确的写法是，在if逻辑内echo "<script>window.history.back();</script>"代码下增加一行die();或者exit();终止后面的代码执行流程。  

#### 下面的代码有什么安全问题？请指出并修正。
```php
<?php echo $_GET["username"]; ?>
```
此题考察PHP代码安全问题。这段代码的主要作用是，把参数username的内容输出到页面中。代码中限制了只能输出一个字符串到页面上，但参数username可控，且没有对参数做任何过滤就echo到页面上，可造成跨站脚本攻击。传入参数`username=<script>alert(1);</script>`,即可触发XSS。修复方法是对username参数进行必要的字符过滤。

#### 下面这段PHP代码安全吗？如果有问题，请修正。
```php
<?php
$okay = 0;
$username = $_POST['user'];
$pw = $_POST['pw'];
$sql = "select count(*) from users where username='".$username."'and password='".$pw."' limit 1";
$result = mysql_query($sql);
?>
```
此题考查SQL注入漏洞的原理。这段代码的问题源于没有对post过来的数据进行任何过滤，直接拼接到了SQL语句中，因而产生SQL注入漏洞。闭合掉前面的单引号即可接自己的SQL语句，然后注释掉后面的SQL，例如：user字段post值为`1' union select @@version --`，pw字段随意，就变成了

```php
$sql = "select count(*) from users where username='1' union select @@version --''and password='1' limit 1";
```

#### 下面的代码有什么安全问题？请指出并修正。
```php
<?php
$uid = isset($_COOKIE['uid']) ? $_COOKIE['uid'] : NULL;
if ($uid !== NULL) {
	$flag = UpdateUserEmail($uid, $_POST['email']);
	if ($flag) {
		echo "Update Ur Email Address Successfully.";
	} else {
		echo "Unknow Error, plz contact system's admin for help.";
	}
} else {
	echo "Login Required!";
}
?>
```
此题考察PHP代码安全问题。这段代码的主要作用是，如果用户传递过来的cookie里面包含了uid，那么就更新对应用户的邮箱地址。  
这里存在的安全问题是，可以通过伪造uid修改任意用户的邮箱。因为在执行update操作前，代码只是校验了uid是否为空，没有采用别的方式校验当前提交请求的用户是否为该uid用户。  
修复方法是在更新邮箱前，通过其他因素（如session）判断当前用户是否为该uid用户。

#### URL跳转漏洞是什么？有哪些危害？
本题考察URL跳转漏洞相关内容。  
应用需要和其他的第三方应用交互，以及在自身应用内部根据不同的逻辑将用户引到不同的页面，譬如一个典型的登录借口就经常需要在认证成功后将用户引导到登录之前的页面，整个过程中如果实现不好就可能导致一些安全问题，特定条件下可能引起严重的安全漏洞。  
对于URL跳转一般会有好几种实现方式：  
1. META标签内跳转。  
2. JavaScript跳转。  
3. HTTP头跳转。  
通过以GET或者POST的方式接收将要跳转的URL，然后通过上面的几种方式之一来跳转到目标URL。一方面，由于用户的输入会进入Meta、JavaScript、HTTP头，所以都可能发生相应的上下文的漏洞，如XSS等。但同时，即使只是对于URL跳转功能本身方面存在一个缺陷，因为会将用户浏览器从可信的站点导向不可信站点，如果跳转的时候带有敏感数据，一样可能将敏感数据泄露给不可信的第三方。  
而已用户完全可以借用URL跳转漏洞来欺骗安全意识低的用户，从而实现“中奖”之类的欺诈，这对于一些有在线业务的企业如淘宝等，危害较大。同时，借助URL跳转，也可以突破常见的基于“白名单方式”的一些安全限制，如传统IM里对于URL的传播会进行安全校验，但是对于大公司的域名及URL将直接允许通过并且显示为可信的URL，而一旦该URL里包含一些跳转漏洞则将可能导致安全限制被绕过。  
如果引用一些资源的限制是依赖于“白名单”方式，同样可能被绕过导致安全风险，譬如常见的一些应用允许引入可信站点如youku.com的视频，限制方式往往是检查URL是否为youku.com，如果youku.com内含一个URL跳转漏洞，将导致最终引入的资源属于不可信的第三方资源或者恶意站点，最终导致安全问题。  

#### 下面代码有什么安全问题？请指出并修正。
```
String downFile = request.getParameter("pdf_file"); 
FileInputStream file = new FileInputStream("/upload/pdf/" + downFile);
DownFileUtil.downfile(file);
```
本题考查JSP代码安全问题。  
首先`request.getParameter("pdf_file")`未对用户输入进行过滤，在`FileInputStream file = new FileInputStream("/upload/pdf/" + downFile);`这里可能因为输入不可控造成任意文件下载。例如用户输入： `http://www.exp.com/test.jsp?pdf_file=../../../../../../../etc/passwd`，这样可能造成：  

```
String downFile = request.getParameter("pdf_file"); 
FileInputStream file = new FileInputStream("/upload/pdf/" + "http://www.exp.com/test.jsp?pdf_file=../../../../../../../etc/passwd");
DownFileUtil.downfile("/upload/pdf/../../../../../../../etc/passwd");
```
然后`/etc/passwd`被下载。

#### 什么是fuzz？
漏洞挖掘有三种方法：白盒代码审计、灰盒逆向工程、黑盒测试。其中黑盒的Fuzz测试是效率最高的一种，能够快速验证大量潜在的安全威胁。  
Fuzz测试，也叫做“模糊测试”，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试，它通过向软件输入非法的字段，观测被测试软件是否异常而实现。Fuzz测试的概念非常容易理解，如果我们构造非法的报文并且通过测试工具打入被测设备，那么这就是一个Fuzz测试的测试例执行，大多数测试工程师肯定都尝试过这种测试手段。  
对于网络协议漏洞挖掘来说，Fuzz测试也就意味着打入各种异常报文，然后观察设备是否有异常。

####如何伪造发件人发送欺诈邮件？
根据SMTP协议的规范，隐藏着一个安全漏洞，那就是，收信人是可以伪造的。  
发送过程：  

```
//远程登录服务器，以163邮箱为例
telnet smtp.163.com 25
Trying 123.125.50.138...
Connected to smtp.163.com.
Escape character is '^]'.
220 163.com Anti-spam GT for Coremail System (163com[20141201])

//用户登录
helo 163.com  //用于向服务器表明用户身份
250 OK
auth login
334 dXNlcm5hbWU6
******  //输入经过base64编码的用户名
334 UGFzc3dvcmQ6
******  //输入经过base64编码的密码
235 Authentication successful

//写信
mail from：<******>   //<>中填写发件人的邮箱，即你自己的邮箱名
rcpt to：<******>  //<>中填入收件人的邮箱
data  //回车后就可以开始写邮件内容了
//下面是data下的可选项：
from：发件人名称  //此项可任意填入，将显示在收件箱的‘发件人’一栏，这里就是伪造的关键
to：收件人名称  //可任意填入，将显示在收件箱的‘收件人’一栏
subject：信件主题  //显示在收件箱的‘主题’一栏中
正文  //此时需空一行，即在一空行直接回车，表示正文部分的开始，空行后输入信件的正文内容。
.  //在正文输入结束时输入一个 . （英文输入法下的句号）回车，表示正文部分的结束。这时将显示邮件成功发送的信息。
```

#### 产生安全漏洞的原因是什么？
0

#### 下面代码有什么安全问题？请指出并修正。
```java
String msg = request.getParameter("msg");
if (msg.indexOf('<')>-1 || msg.indexOf('>')>-1) {
	out.println("<span>error</span>");
} else {
	out.println("<input type=hidden name=msg value='" + msg + "' />");
}
```
0

#### 小明
0

### 系统与网络安全
> 系统安全的基本原则就是在一个新系统的构思阶段就必须考虑其安全性的问题，制定并执行安全工作规划（系统安全活动），属于事前分析和预先防护，与传统的事后分析并积累事故经验的思路截然不同。  
> 系统与网络安全主要涉及内核安全、权限控制、系统组件安全、基线检查和网络协议安全等。  

#### PaX
PaX是针对Linux kernel的一个加固补丁，它让Linux内核的内存页受限于最小权限原则，是一个有效的防御“系统级别0day”的方案。第1版的设计和实现诞生于2000年，但是当时Linux内核不收PaX进入upstream，这是因为很多人觉得PaX不是这么好维护，之后Linux内核推出了LSM(Linux Security Module)，LSM利用一堆capability的机制提供了一些限制用户态程序访问控制的接口，SELinux和Apparmor就是基于LSM开发的。需要注意的是LSM并不是一个传统意义上的Linux kernel module。  
当我们谈到PaX时都会写Grsecurity/PaX，这是因为PaX从一开始就主要关注如何防御和检测memory corruption，后来Grsecurity社区发现PaX和他们所关注的非常类似，所以就合并了，在很长的一段时间里PaX主要关注memory corruption，而Grsecurity则实现其他的功能，包括RBAC，但后来2个社区的工作开始模糊了：包括usercopy、stackleak、randstruct等都是整个Grsecurity/PaX共同实现的特性。  
PaX team认为会导致漏洞利用的bug给予了攻击者（区分攻击者和黑客是不同的term）在3个不同层面上访问被攻击进程的机会。  
1. 执行任意代码  
2. 执行现有代码但打破了原有的执行顺序  
3. 原有的执行顺序执行现有代码，但加载任意数据  
需要明白的是，Windows和Linux系统级防御机制的很多思想都来自PaX的理论研究成果，差别仅仅在于不同操作系统中的内核实现及所叫的名字不同。  

#### 简述你所知道的ARP欺骗的方式。
**攻击者仅仅欺骗攻击主机（单向）**
主机C向主机B发送伪造的ARP回应包，声称自己的MAC地址就是网关对应的IP，这样，主机B就会将所有的流量发送到主机C（攻击者），主机C开启ip\_forward路由转发功能将数据包进行转发。  
**攻击者仅仅欺骗被攻击主机，同时在本地进行iptable NAT转发（双向）**
主机C向主机B发送伪造的ARP回应包，声称自己的MAC地址就是网关对应的IP，这样，主机B就会将所有的流量发送到主机C（攻击者），同时，攻击者在本地使用iptables进行NAT转换，这样就可以接收到网关返回的数据包，完成双向流量窃取的目的。  
**攻击者同时欺骗被攻击主机和网关（双向）**
主机C同时欺骗主机B和网关，实现数据中转，并监听到所有主机B的数据（双向），主机C向网关发送ARP回应包，声称自己是主机B，同时向主机B发送ARP回应包，声称自己是网关，这样，网关和主机B两边的流量都会发往主机C，主机C并不需要使用iptables做特殊的转发，只需要打开ip\_forward路由开关（即打开转发功能），使主机C具有数据包转发的功能即可，这样就可以成功劫持主机B的流量数据。  

#### 简述NTP反射放大攻击的原理。
要了解NTP放大攻击，我们需要重点关注协议中的一个字段——Mode字段。这个字段表示了NTP数据包的类型和用途，总共有7种模式。  
0 未定义。  
1 主动对等体模式。  
2 被动对等体模式。  
3 客户模式。  
4 服务器模式。  
5 广播模式或组播模式。  
6 此报文为NTP控制报文（MODE\_CONTROL）。  
7 预留给内部使用（MODE\_PRIVATE）。  
其中编号为7的NTP报文是专门预留给ntpdc（Linux下默认安装的ntp client）使用的。ntpdc支持很多的指令，如下所示：  

```
/Users/huangchenyao >ntpdc -n -i time-a.nist.gov
ntpdc> ?
ntpdc commands:
addpeer      controlkey   fudge        keytype      quit         timeout      
addrefclock  ctlstats     help         listpeers    readkeys     timerstats   
addserver    debug        host         loopinfo     requestkey   traps        
addtrap      delay        hostnames    memstats     reset        trustedkey   
authinfo     delrestrict  ifreload     monlist      reslist      unconfig     
broadcast    disable      ifstats      passwd       restrict     unrestrict   
clkbug       dmpeers      iostats      peers        showpeer     untrustedkey 
clockstat    enable       kerninfo     preset       sysinfo      version      
clrtrap      exit         keyid        pstats       sysstats   
```
其中有一个存在风险的指令：monlist。  
Monlist指令可以获取与目标NTP Server进行过同步的最后600个客户机IP。这意味着，一个很小的请求包，就能获取到大量的活动IP地址组成的连续UDP包。在这种情况下，实际的攻击效果是：  
1. 发送回包比是1：73。  
2. 发送数据量和回收数据量是234bytes:73&times;482bytes，约等于1：562。  
3. 10M的通信流量可以得到5620M的攻击流量。  
分析到这里，我们需要理解一个反射（relection）的概念，从本质上说，反射攻击和ip spoofing、mac spoofing是一个道理。  
1. 正常情况下：client和server建立UDP或者TCP通信，数据在client和server之间传输。  
2. 反射攻击情况下：攻击者通过将数据包的源IP伪造为受害者的IP，并发往server，对于server来说，这个数据包就是来自于受害者的数据包，于是server对这个数据包进行相应，并向受害者返回对应的应答数据包。而UDP的无连接通信模式更是加剧了这个过程的简单化，黑客可以直接以“无状态的模式”向server发送大量的伪造包，而不用建立任何有效连接。  

####简述心脏滴血漏洞的原理。
从黑客角度上说，要发动这种攻击，需要借助“协议数据包篡改技术”，通过构造“畸形”的SSL数据包向引入了存在漏洞的openssl代码库的Web Server发起请求，从而获取目标Web Server的TLS Stack上和当前数据报相邻的64KB的数据（之所以是64kb，也和SSL协议本身有关系，协议中可供黑客修改的这个字段的最大长度是3bytes）。  
1. 函数接受用户发送到服务端的SSLv3数据包，并对其中的字段进行解析。  
2. 代码无条件“信任”数据包头中的length字段，作为此次SSL数据包的总长度。  
3. 在内存申请和填充响应数据包的时候，使用了“受污染”的长度字段。  
4. 从而导致“内存越界数据获取”，将当前TLS Stack中的、和当前SSL Record指针相邻的、最大长度64KB的内存数据全部返回给了数据请求方。  
黑客只需要将原始正常发送的SSLv3数据包中的length字段改为0xFFFF，就可以非法获取目标Web Server的64KB泄露数据。  
需要注意的是，虽然长度2字节理论上最大是64KB，但是RFC文档规定heartbeat最大长度不能超过2<sup>14</sup>B，也就是16KB，除去type和payload\_length、padding这3部分，所以最大数据长度会略小于16KB，为16KB-19B

#### 怎样查看Linux当前网络连接状态？要求端口与PID关联。
`netstat -atnp`

#### 什么是0day？
在计算机领域中，零日漏洞或零时差漏洞（英语：Zero-day exploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（英语：Zero-day attack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。

#### 什么是“肉鸡”？
僵尸主机（英语：Zombie computer），简称“僵尸（zombie）”，又称“肉鸡”（谐音“肉机”）或“傀儡机”，是指接入互联网受恶意软件感染后，受控于黑客的电脑。其可以随时按照黑客的命令与控制（C&C, command and control）指令展开拒绝服务（DoS）攻击或发送垃圾信息。通常，一部被侵占的电脑只是僵尸网络里面众多中的一个，会被用来去运行一连串的或远端控制的恶意程序。一般电脑的拥有者都没有察觉到自己的系统已经被“僵尸化”，就仿佛是没有自主意识的僵尸一般。

#### 简述WEP无线加密方式容易遭到破解的原理。
RC4

#### 什么是TCP半开扫描？你还知道哪些扫描方式？
扫描器向目标主机的一个端口发送请求连接的SYN包，扫描器在收到SYN/ACK后，不是发送的ACK应答而是发送RST包请求断开连接。这样，三次握手就没有完成，无法建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有root权限。  
端口开放：1、Client发送SYN  2、Server端发送SYN/ACK 3、Client发送RST断开（只需要前两步就可以判断端口开放）  
端口关闭：1、Client发送SYN  2、Server端回复RST（表示端口关闭）  
优点：SYN扫描要比TCP Connect()扫描隐蔽一些，SYN仅仅需要发送初始的SYN数据包给目标主机，如果端口开放，则相应SYN-ACK数据包；如果关闭，则响应RST数据包；  

端口扫描：

- TCP SYN扫描（TCP半开扫描）
- TCP connect扫描
- 秘密扫描
  - TCP FIN扫描
  - TCP ACK扫描
  - NULL扫描
  - XMAS扫描
  - SYN/ACK扫描
- 其他扫描
  - UDP扫描
  - IP头信息dumb扫描
  - IP分段扫描
  - 慢速扫描
  - 乱序扫描

[参考文章](http://zenoh.iteye.com/blog/1264915)  
[nmap](https://nmap.org/man/zh/man-port-scanning-techniques.html)  

### 逆向与调试
> 逆向与调试需要掌握x86&64汇编、常见调试器用法、Linux与Windows编程、缓冲区溢出、程序加壳脱壳、花指令和代码审计等技能。

#### Windows系统的SSDT和SSDT hook是什么意思？Linux系统上与SSDT相对应的机制是什么？
SSDT(System Services Descriptor Table)即系统服务描述符表，他将ring3的Win32 API和ring0的内核API联系了起来。SSDT并不仅仅包含一个庞大的地址索引表，还包含着一些其他有用的信息，诸如地址索引的基地址、服务函数个数等。  
SSDT HOOK指的是通过修改SSDT表里面存储的ring0的内核API函数地址，替换为自定义函数地址，使得自定义函数先于系统函数调用，从而实现一些关键的系统动作进行过滤、监控的目的。  
Linux下与之对应的是sys\_call\_table。  

#### 简述脱壳中ESP定律的原理。
这是软件逆向脱壳的一条经验法则，我们可以把壳想成一个子程序，壳在把代码解压前后，必须要做的是遵循堆栈平衡的原理。

#### 什么是DLL劫持？请描述原理。
DLL劫持指的是，当一个可执行文件（一般为.exe文件）运行时，Windows加载器需要将可执行模块映射到进程的地址空间中，加载器分析可执行模块的输入表，设法找出任何需要的DLL，并将它们映射到进程的地址空间中。  
其原理是，由于输入表中只包含DLL名而没有他的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在目录加载DLL，如果没有找到，则在Windows系统目录中查找，最后在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供相同的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，而这个伪造的DLL会重写某些关键的系统函数，先执行恶意操作，再跳到系统DLL正常函数里执行。  

#### 下面代码有什么安全问题？请指出并修正。
```c
int Mname()
{
	char NewName[30];
	unsigned int len = 0;
	for (;Oldname[len]!='\0';++len)
	{
		NewName[len] = Oldname[len];
	}
	return 0;
}
```
缓冲区溢出。

#### 什么叫脱壳？
某些计算机软件为了保护自身的一些关键算法、功能或者提供收费服务，会包含一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成保护软件的任务，就像动植物的壳一般都是在身体外面一样理所当然（但后来也出现了所谓的“壳中带籽”的壳）。由于这段程序和自然界的壳在功能上有很多相同的地方，因而得名。软件加壳是作者编写好软件后，为了保护自己的代码或维护知识产权等而常用的手段。目前有很多加壳工具，既然有矛，自然就有盾，脱壳即去掉软件所加的壳，有手动脱壳和自动脱壳之分。  
从技术角度出发，壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密……当加壳后的文件执行时，壳这段代码先于原始程序运行，把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。软件的壳可分为加密壳、压缩壳、伪装壳、多层壳等，目的都是隐藏程序真正的OEP（入口点，防止被破解）。

#### 将一个由“:”连接的网卡地址字符串拆分并存储到char buf[6]中，例如，“00:24:E8:FA:A5:09”存储为char buf[6] = 0x00，0x24，0xE8，0xFA，0xA5，0x09。

```c
void macStr2Byte(char *str)//00:24:E8:FA:A5:09
{
	char buf[6];
	int k=0, res=0, temp=0;
	if (!str)
		return;
	for (int i=0; i<strlen(str); i++)
	{
		if (str[i]==':')
		{
			printf("%d,", res);
			buf[k++]=res;
			res=0, temp=0;
		}
		else
		{
			if (str[i]-'A'>=0)
				temp=str[i]-'A'+10;
			else
				temp=str[i]-'0';
			res=res*16+temp;
		}
	}
}
```

#### ring3与ring0有何区别？从Windows 2000到Windows7的升级过程中，从ring3进入ring0有何变化？
Intel的x86处理器是通过Ring级别来进行访问控制的，共分4层，从Ring0到Ring3（后面简称R0、R1、R2、R3）。R0拥有最高的权限，R3拥有最低的权限。按照Intel原有的构想，应用程序工作在R3层，只能访问R3层的数据；操作系统工作在R0层，可以访问所有层的数据；而其他驱动程序位于R1、R2层，每一层只能访问本层以及权限更低层的数据。  
这应该是很好的设计，这样操作系统工作在最核心层，没有其他代码可以修改它；其他驱动程序工作在R1、R2层，有要求则向R0层调用，这样可以有效保障操作系统的安全性。但现在的OS，包括Windows和Linux都没有采用4层权限，而只是使用2层——R0层和R3层，分别存放操作系统数据和应用程序数据，从而导致一旦驱动加载就运行在R0层，就拥有了和操作系统同样的权限。面向用户的应用层程序则工作在R3层。  
Windows 2000使用软中断int 0x2e方式从R3进入R0；WindowsXP以后版本使用sysenter方式即快速调用方式从R3进入R0。

#### 请描述栈溢出的原理。
栈溢出就是不顾栈中分配的局部数据块大小，恶意向该数据块写入了过多的数据，导致数据越界，结果覆盖了相邻的数据。栈溢出攻击则可以理解为在长字符串中嵌入一段代码，并将过程的返回地址覆盖为这段代码的地址，这样当过程返回时，程序就转而开始执行这段自编的代码了。

## 计算机科学

### 软件工程

#### 软件开发的几个模型
- 瀑布模型：上一阶段的输出是下一阶段的输入，保证质量
- 快速原型模型，抛弃型or渐进型，没有反馈环
- 增量模型：满足需求的子集，瀑布和快速都是满足全部需求
- 螺旋模型：风险分析
- 喷泉模型：迭代，无缝

#### UML图里面需求阶段需要画哪几个？


#### 软件开发生命周期
1. 问题定义
2. 可行性研究
3. 需求分析
4. 总体设计
5. 详细设计
6. 编码与单元测试
7. 综合测试
8. 软件维护

### 数据结构


### 计算机网络

#### OSI
OSI(open system interconnection)，开放系统互联，有时候会写OSI/RM(open system interconnection reference model)，开放系统互联参考模型，共7层。  

1. 物理层：比特流，定义各种物理层接口标准
2. 数据链路层：帧，成帧、差错控制、流量控制和传输管理
  - SDLC
  - HDLC：广域网，面向比特，0比特插入法
  - PPP：广域网，面向字节，7E，7D
  - STP
  - 帧中继
3. 网络层：数据报，路由选择、流量控制、拥塞控制、差错控制和网际互联
  - IP
  - IPX
  - ICMP：终点不可达、源点抑制、时间超过、参数问题、改变路由，ping工作在应用层，tracert工作在网络层
  - IGMP
  - ARP
  - RARP
  - OSPF：全网的拓扑结构图
4. 传输层：报文段(T)、数据报(U)，负责主机中两个进程之间的通信。
  - TCP
  - UDP
5. 会话层：允许不同主机中个进程之间的会话。
6. 表示层：处理在两个通信系统中交换信息的表示方式。
7. 应用层：用户与网络的界面
  - 各种

#### TCP/IP有几层？各层的协议？协议的区别？
1. 应用层
2. 运输层
3. 网际层
4. 网络接口层

#### TCP/UDP区别
- TCP：有连接，全双工，可靠，面向字节流，每一条连接只能由两个端点
  - 头部最短20B
  - 三次握手，SYN→，SYN+ACK←，ACK→
  - 四次挥手，FIN→，ACK←，（data）←,FIN+ACK←，ACK→
  - 慢开始之指数变大，拥塞避免之加法增大
  - 快重传，快恢复
- UDP：无连接，尽最大努力交付，面向报文，无流量控制，无拥塞控制，速度快
  - 头部8B
  - 校验和可选，二进制反码运算求和再取反

#### CP/IP与OSI对比
- 同
  1. 分层结构，功能大体相似
  2. 基于独立的协议栈
  3. 解决异构网络的互联
- 异
  1. OSI精确定义了服务、协议、接口，面向对象的思想
  2. OSI通用性良好，TCP/IP基于已有协议不适合其他协议栈
  3. T考虑到多种异构网互联问题
  4. O网络层支持有连接和无连接，T网际层只有无连接，传输层无连接和面向连接
  5. O效率低

#### v4/v6


### 操作系统

#### 进程与线程
1. 调度。线程是独立调度的基本单位，进程是拥有资源的基本单位
2. 拥有资源。进程拥有资源，线程不拥有资源。进程不共享资源，同一个进程的线程共享资源
3. 并发性。引入线程可以提高并发性
4. 系统开销。创建或撤销进程开销大，分配或回收资源，线程开销小
5. 地址空间和其他资源。进程的地址空间独立，进程内的线程对其他进程不可见
6. 通信方面。进程间通信需要用同步和互斥，线程间通信可以直接读写进程数据段（全局变量）

#### PV操作
- 同步，直接制约关系
- 互斥，间接制约关系
- wait(P)，申请资源
- signal(V)，释放资源

#### 饥饿
- 先来先服务，有利于CPU繁忙型，简单，低效
- 短作业优先，饥饿，导致长作业长期不被调度
- 优先级调度，剥夺or非剥夺
- 高响应比优先级调度
- 时间片轮转调度
- 多级反馈队列调度


#### 死锁，银行家算法
1. 互斥条件
2. 不剥夺条件
3. 请求与保持条件
4. 循环等待条件  
破坏任意一个都可以预防死锁  
用某种方法防止系统进入不安全状态避免死锁，银行家算法  
死锁检测和解除，资源分配图

#### 什么是局部性原理？
- 时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。
- 空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。

#### 微内核和宏内核
大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，性能高，内核代码难以维护    
微内核按内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，降低了内核设计的复杂性，移出的代码按分层原则分成若干服务程序，相互独立。分离了内核与服务、服务与服务，保证系统可靠性。性能问题，需要频繁地在核心态和用户态之间切换。

### 软件测试

#### 测试手段
单元、集成、系统、验收、回归

### 编程方面

#### 面向过程的三个特征
- 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
- 继承，让某个类型的对象获得另一个类型的对象的属性的方法。父子。
- 多态，
  - 编译时多态，重载
  - 运行时多态，父类虚函数，子类重写该函数，父类指针指向子类对象，会调用相应子类方法
- 虚函数和纯虚函数，虚函数和纯虚函数都是用来实现多态的，纯虚函数在父类里面没有具体实现方法，虚函数f(); 纯虚函数f() = 0;

#### java是否多继承
不是

#### 函数传参方式
- 值
- 引用
- 指针

#### 类的关系
- 继承，A是B爸爸
- 实现，B实现了A的接口
- 依赖，B偶尔临时使用了A的方法
- 关联：长期性的，双方关系平等的，比如A是B的朋友
- 聚合：关联的特例，A有B，例如计算机和CPU
- 组合：关联的特例，强聚合，整体和部分不可分，部分88，整体就88，人和大脑

#### const，static

#### 各种排序算法
看王道

### 数据库

#### 范式
- 第一范式（无重复的列） 定义：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。通俗解释：一个字段只存储一项信息  

| 学号 | 姓名 |   班级    |
| :--: | :--: | :-------: |
| 0001 | 小红 | 高三年1班 |
改成
| 学号 | 姓名 |  年级  | 班级 |
| :--: | :--: | :----: | :--: |
| 0001 | 小红 | 高三年 | 1班  |
- 第二范式（属性完全依赖于主键） 定义：满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。通俗解释：任意一个字段都只依赖表中的同一个字段

| 学生证 | 名称 | 学生证号 | 学生证办理时间 | 借书证名称 | 借书证号 | 借书证办理时间 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |      |      |      |      |      |
改成2张表如下：  
学生证表:
| 学生证 | 学生证号 | 学生证办理时间 |
| :--: | :--: | :--: |
|      |      |      |
借书证表：
| 借书证 | 借书证号 | 借书证办理时间 |
| :--: | :--: | :--: |
|      |      |      |

- 第三范式（属性不能传递依赖于主属性） 定义：满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。通俗理解：一张表最多只存2层同类型信息
| 爸爸 | 儿子 | 女儿 | 女儿的小熊 | 女儿的海绵宝宝 |
| :--: | :--: | :--: | :--: | :--: |
|      |      |      |      |      |
改成：  
爸爸信息表：

| 爸爸 | 儿子 | 女儿 |
| :--: | :--: | :--: |
|      |      |      |
女儿信息表：
| 女儿 | 女儿的小熊 | 女儿的海绵宝宝 |
| :--: | :--: | :--: |
|      |      |      |

### 密码学

#### MD5

#### SSL

### 其他

#### 网卡工作的三种模式
- 广播模式：接收广播帧
- 直接模式：只接收自己地址的帧
- 混杂模式：接收所有流过网卡的帧

