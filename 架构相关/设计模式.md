[TOC]

# 设计模式

## 六大原则

1. 单一职责原则

   每个类只负责单一的功能，且不可太多，并且功能要做到极致

   最应该遵守的原则，这样就不会有很多的冗余代码出现

2. 里氏替换原则

   子类可以替代父类，并且能正常工作，即子类一般不应该重写父类的方法

3. 接口隔离原则

   接口最小化原则，一个接口拥有的行为应该尽可能小

4. 依赖倒置原则

  高层模块不该依赖于低层模块，二者都应该依赖于抽象

  抽象不应该依赖于细节，细节应该依赖于抽象

5. 迪米特法则

   最小知道原则

   高内聚，低耦合

   一个类应该尽量不要知道其他类太多的东西，不要和陌生的类有太多接触，一个类应当不要让外部的类知道自己太多

6. 开闭原则

   对修改关闭，对扩展开放

   这个原则更像是前五个原则的总纲，前五个原则就是围着它转的，只要我们尽量的遵守前五个原则，那么设计出来的系统应该就比较符合开闭原则了，相反，如果你违背了太多，那么你的系统或许也不太遵循开闭原则

**用抽象构建框架，用细节实现扩展**

## 创建型

### 单例模式

目的：尽可能节约内存空间，减少GC消耗，并且程序能正常运行

能否做成单例：这些类在应用中如果有两个或者两个以上的实例会引起错误，或者说，这些类在整个应用中，同一时刻，有且只能有一种状态

#### 最简单的单例

一个最简单的例子：

```java
public class Singleton {
  //一个静态的实例
  private static Singleton singleton;

  //私有化构造函数
  private Singleton() {
  }

  //给出一个公共的静态方法返回一个单一实例
  public static Singleton getInstance() {
    if (singleton == null) {
      singleton = new Singleton();
    }
    return singleton;
  }
}
```

这种单例的方法会有并发问题，同时进入==null，都为true，然后会重复创建单例

#### 使用同步块

```java
public class BadSynchronizedSingleton {
    //一个静态的实例
    private static BadSynchronizedSingleton synchronizedSingleton;

    //私有化构造函数
    private BadSynchronizedSingleton() {
    }

    //给出一个公共的静态方法返回一个单一实例
    public synchronized static BadSynchronizedSingleton getInstance() {
        if (synchronizedSingleton == null) {
            synchronizedSingleton = new BadSynchronizedSingleton();
        }
        return synchronizedSingleton;
    }
}
```

这种使用同步块的模式，所有线程访问都需要进行等待，很影响效率

#### 双重加锁

```java
public class SynchronizedSingleton {
    //一个静态的实例
    private static SynchronizedSingleton synchronizedSingleton;

    //私有化构造函数
    private SynchronizedSingleton() {
    }

    //给出一个公共的静态方法返回一个单一实例
    public static SynchronizedSingleton getInstance() {
        if (synchronizedSingleton == null) {
            synchronized (SynchronizedSingleton.class) {
                if (synchronizedSingleton == null) {
                    synchronizedSingleton = new SynchronizedSingleton();
                }
            }
        }
        return synchronizedSingleton;
    }
}
```

1. 先判空，如果没有才进入同步块，否则直接返回，这样节省了很多无谓的线程等待时间
2. 进入同步块后，还需要判空一次，防止并发时，都进入了同步块，重复创建单例的情况

#### 饿汉模式

双重加锁即饱汉模式，对应的饿汉模式如下：

```java
//饿汉模式，很饿很着急，所以类加载时即创建实例对象
public class HungarySingleton {
    private static HungarySingleton singleton = new HungarySingleton();

    private HungarySingleton() {
    }

    public static HungarySingleton getInstance() {
        return singleton;
    }
}
```

饱汉模式不用考虑各种并发问题，启动后又jvm自行创建单例，但如果这种饱汉模式的单例过多，可能会导致系统中存在很多并没有使用到的单例被预先创建了。

#### 静态内部类

```java
public class InnerClassSingleton {
    private InnerClassSingleton() {
    }

    public static InnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final InnerClassSingleton INSTANCE = new InnerClassSingleton();
    }
}
```

1. 当getInstance方法第一次被调用的时候，读取SingletonHolder.instance，内部类SingletonHolder开始初始化
2. 而类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性
3. 这个模式的优点在于，不用实现同步代码，而且可以延迟加载，规避了饱汉模式的缺点。

#### 单例注册表

以上模式的构造方法是私有的，不可继承，Spring为实现单例类可继承，使用的是单例注册表的方式

1. 使用map实现注册表；
2. 使用protect修饰构造方法；

```java
public class RegSingleton {
    // 通过 Map 实现单例注册表
    private final static Map<String, Object> singletonObjects = new ConcurrentHashMap<>(16);

    public static Object getSingleton(String className) {
        assert className != null;
        synchronized (singletonObjects) {
            // 检查缓存中是否存在实例
            if (singletonObjects.get(className) == null) {
                try {
                    // 如果实例对象在不存在，注册到单例注册表中
                    singletonObjects.put(className, Class.forName(className).getConstructor().newInstance());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            return singletonObjects.get(className);
        }
    }
}
```

#### 总结

1. 饿汉模式，一开始就创建，有可能会构造出很多暂时还不需要使用的对象
2. 饱汉模式，需要时才创建，但需要增加同步代码，增加系统开销
3. 静态内部类，上面两者的结合，不需要同步代码，又能延迟创建对象
4. 单例注册表，Spring实现单例的方式，为了使单例类可继承

### 简单工厂模式

### 工厂方法模式

### 抽象工厂模式

### 建造者模式

### 原型模式

## 结构型

### 代理模式

在原有类的行为基础上，加入一些多出的行为，甚至完全替换原有的行为

#### 静态代理



#### 动态代理



### 适配器模式

### 装饰器模式

### 桥接模式

### 组合模式

### 享元模式

### 外观模式

## 行为型

### 观察者模式

### 模板方法模式

### 命令模式

### 状态模式

### 职责链模式

### 解释器模式

### 中介者模式

### 访问者模式

### 策略模式

### 备忘录模式

### 迭代器模式