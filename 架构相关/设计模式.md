[TOC]

# 设计模式

## 六大原则

#### 单一职责原则

每个类只负责单一的功能，且不可太多，并且功能要做到极致

最应该遵守的原则，这样就不会有很多的冗余代码出现

#### 里氏替换原则

子类可以替代父类，并且能正常工作，即子类一般不应该重写父类的方法

#### 接口隔离原则

接口最小化原则，一个接口拥有的行为应该尽可能小

#### 依赖倒置原则

高层模块不该依赖于低层模块，二者都应该依赖于抽象

抽象不应该依赖于细节，细节应该依赖于抽象

#### 迪米特法则

最小知道原则

高内聚，低耦合

一个类应该尽量不要知道其他类太多的东西，不要和陌生的类有太多接触，一个类应当不要让外部的类知道自己太多

#### 开闭原则

对修改关闭，对扩展开放

这个原则更像是前五个原则的总纲，前五个原则就是围着它转的，只要我们尽量的遵守前五个原则，那么设计出来的系统应该就比较符合开闭原则了，相反，如果你违背了太多，那么你的系统或许也不太遵循开闭原则

**用抽象构建框架，用细节实现扩展**

## 创建型

### 单例模式

目的：尽可能节约内存空间，减少GC消耗，并且程序能正常运行

能否做成单例：这些类在应用中如果有两个或者两个以上的实例会引起错误，或者说，这些类在整个应用中，同一时刻，有且只能有一种状态

#### 最简单的单例

一个最简单的例子：

```java
public class Singleton {
  //一个静态的实例
  private static Singleton singleton;

  //私有化构造函数
  private Singleton() {
  }

  //给出一个公共的静态方法返回一个单一实例
  public static Singleton getInstance() {
    if (singleton == null) {
      singleton = new Singleton();
    }
    return singleton;
  }
}
```

这种单例的方法会有并发问题，同时进入==null，都为true，然后会重复创建单例

#### 使用同步块

```java
public class BadSynchronizedSingleton {
    //一个静态的实例
    private static BadSynchronizedSingleton synchronizedSingleton;

    //私有化构造函数
    private BadSynchronizedSingleton() {
    }

    //给出一个公共的静态方法返回一个单一实例
    public synchronized static BadSynchronizedSingleton getInstance() {
        if (synchronizedSingleton == null) {
            synchronizedSingleton = new BadSynchronizedSingleton();
        }
        return synchronizedSingleton;
    }
}
```

这种使用同步块的模式，所有线程访问都需要进行等待，很影响效率

#### 双重加锁

```java
public class SynchronizedSingleton {
    //一个静态的实例
    private static SynchronizedSingleton synchronizedSingleton;

    //私有化构造函数
    private SynchronizedSingleton() {
    }

    //给出一个公共的静态方法返回一个单一实例
    public static SynchronizedSingleton getInstance() {
        if (synchronizedSingleton == null) {
            synchronized (SynchronizedSingleton.class) {
                if (synchronizedSingleton == null) {
                    synchronizedSingleton = new SynchronizedSingleton();
                }
            }
        }
        return synchronizedSingleton;
    }
}
```

1. 先判空，如果没有才进入同步块，否则直接返回，这样节省了很多无谓的线程等待时间
2. 进入同步块后，还需要判空一次，防止并发时，都进入了同步块，重复创建单例的情况

#### 饿汉模式

双重加锁即饱汉模式，对应的饿汉模式如下：

```java
//饿汉模式，很饿很着急，所以类加载时即创建实例对象
public class HungarySingleton {
    private static HungarySingleton singleton = new HungarySingleton();

    private HungarySingleton() {
    }

    public static HungarySingleton getInstance() {
        return singleton;
    }
}
```

饱汉模式不用考虑各种并发问题，启动后又jvm自行创建单例，但如果这种饱汉模式的单例过多，可能会导致系统中存在很多并没有使用到的单例被预先创建了。

#### 静态内部类

```java
public class InnerClassSingleton {
    private InnerClassSingleton() {
    }

    public static InnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final InnerClassSingleton INSTANCE = new InnerClassSingleton();
    }
}
```

1. 当getInstance方法第一次被调用的时候，读取SingletonHolder.instance，内部类SingletonHolder开始初始化
2. 而类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性
3. 这个模式的优点在于，不用实现同步代码，而且可以延迟加载，规避了饱汉模式的缺点。

#### 单例注册表

以上模式的构造方法是私有的，不可继承，Spring为实现单例类可继承，使用的是单例注册表的方式

1. 使用map实现注册表；
2. 使用protect修饰构造方法；

```java
public class RegSingleton {
    // 通过 Map 实现单例注册表
    private final static Map<String, Object> singletonObjects = new ConcurrentHashMap<>(16);

    public static Object getSingleton(String className) {
        assert className != null;
        synchronized (singletonObjects) {
            // 检查缓存中是否存在实例
            if (singletonObjects.get(className) == null) {
                try {
                    // 如果实例对象在不存在，注册到单例注册表中
                    singletonObjects.put(className, Class.forName(className).getConstructor().newInstance());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            return singletonObjects.get(className);
        }
    }
}
```

#### 总结

1. 饿汉模式，一开始就创建，有可能会构造出很多暂时还不需要使用的对象
2. 饱汉模式，需要时才创建，但需要增加同步代码，增加系统开销
3. 静态内部类，上面两者的结合，不需要同步代码，又能延迟创建对象
4. 单例注册表，Spring实现单例的方式，为了使单例类可继承

### 简单工厂模式

### 工厂方法模式

### 抽象工厂模式

### 建造者模式

### 原型模式

## 结构型

### 代理模式

在原有类的行为基础上，加入一些多出的行为，甚至完全替换原有的行为

```java
public interface MyInterface {
    String doSomething();
}

public class MyObject implements MyInterface {
    @Override
    public String doSomething() {
        System.out.println("do sth");
        return "do sth";
    }
}
```

#### 静态代理

静态代理采用的方式就是我们手动的将这些行为换进去，然后让编译器帮我们编译，同时也就将字节码在原有类的基础上加入一些其他的东西或者替换原有的东西，产生一个新的与原有类接口相同却行为不同的类型

```java
public class StaticProxy implements MyInterface {
    private MyInterface myInterface;

    public StaticProxy(MyInterface myInterface) {
        this.myInterface = myInterface;
    }

    @Override
    public String doSomething() {
        System.out.println("static proxy do something");
        return "proxy: " + myInterface.doSomething();
    }
}

// 静态代理
MyInterface staticProxyObj = new StaticProxy(new MyObject());
staticProxyObj.doSomething();
```

#### JDK动态代理

Java中JDK动态代理主要是依赖InvocationHandler(Interface)和Proxy(Class)来完成的

InvocationHandler这个接口的唯一一个方法invoke:

```java
/**
 * @param   proxy 指代我们所代理的那个真实对象
 * @param   method 指代的是我们所要调用真实对象的某个方法的Method对象
 * @param   args 指代的是调用真实对象某个方法时接受的参数
 */
Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
```
Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是newProxyInstance这个方法：

```java
/**
 * @param   loader 使用哪个ClassLoader对象来对生成的代理对象进行加载
 * @param   interfaces 代理的类实现的接口列表
 * @param   h 动态代理在调用方法的时候，会关联到的InvocationHandler对象
 */
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h);
```

代码示例：

```java
public class DynamicProxy implements InvocationHandler {
    private Object object;

    public DynamicProxy(Object object) {
        this.object = object;
    }

    public void before() {
        System.out.println("do sth before");
    }

    public void after() {
        System.out.println("do sth after");
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("dynamic proxy name: " + proxy.getClass());
        System.out.println("method: " + method.getName());
        System.out.println("args: " + Arrays.toString(args));

        this.before();
        Object result = method.invoke(object, args);
        this.after();

        return result;
    }
}

ClassLoader classLoader = obj.getClass().getClassLoader();
Class<?>[] interfaces = obj.getClass().getInterfaces();
InvocationHandler handler = new DynamicProxy(obj);
MyInterface dynamicProxyObj = (MyInterface) Proxy.newProxyInstance(classLoader, interfaces, handler);
dynamicProxyObj.doSomething();
```

#### CGLIB代理

```java
/**
 * @param obj 表示要进行增强的对象
 * @param method 表示拦截的方法
 * @param args 数组表示参数列表，基本数据类型需要传入其包装类型，如int-->Integer、long-Long、double-->Double
 * @param proxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用
 */
public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;
```

代码示例：

```java
public class MyObject2 {
    public String doSomething() {
        System.out.println("obj2 do sth, no implement");
        return "obj2 do sth";
    }
}

public class MyObject2Interceptor implements MethodInterceptor {
    private void before() {
        System.out.println("do sth before");
    }

    private void after() {
        System.out.println("do sth after");
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        before();
        // 注意这里是调用invokeSuper而不是invoke，否则死循环，proxy.invokeSuper执行的是原始类的方法，proxy.invoke执行的是子类的方法
        Object result = proxy.invokeSuper(obj, args);
        after();
        return result;
    }
}

Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(MyObject2.class);
enhancer.setCallback(new MyObject2Interceptor());
MyObject2 obj2 = (MyObject2) enhancer.create();
obj2.doSomething();
```

#### 总结

1. 静态代理实现比较方便，但不同接口会有不同代理类，会有冗余代码
2. Jdk动态代理，减少了冗余代码，运行时才生成代理类，但Jdk动态代理是基于接口的
3. cglib代理无需接口，采用了更底层的字节码技术，没有接口也能实现代理，但创建代理类消耗的时间会更大

### 适配器模式

### 装饰器模式

### 桥接模式

### 组合模式

### 享元模式

### 外观模式

## 行为型

### 观察者模式

### 模板方法模式

### 命令模式

### 状态模式

### 职责链模式

### 解释器模式

### 中介者模式

### 访问者模式

### 策略模式

### 备忘录模式

### 迭代器模式