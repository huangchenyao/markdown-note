[TOC]

# Redis数据结构

## 内部数据结构

### SDS（Simple Dynamic String，简单动态字符串）

#### sds的用途

##### 实现字符串对象

redis是k-v存储的，value可以是各种各样的类型（包括字符串），但key都是字符串，redis的key的数据结构就是用的sds。

##### 取代C语言char*

在 Redis 中绝大部分字符串都是使用sds来表示， 客户端传入服务器的协议内容、 aof 缓存、 返回给客户端的回复， 等等， 这些重要的内容都是由 sds 类型来保存的。

#### Redis的字符串

C语言字符串存在的问题：

- 获取长度低效，复杂度为O(n)
- 对字符串进行追加，需要重新分配内存
- 以\0表示字符串结尾

Redis的sds定义如下：

```C
typedef char *sds;

struct sdshdr {
    // buf 已占用长度
    int len;

    // buf 剩余可用长度
    int free;

    // 实际保存字符串数据的地方
    char buf[];
};
```

其中，类型 `sds` 是 `char *` 的别名（alias），而结构 `sdshdr` 则保存了 `len` 、 `free` 和 `buf` 三个属性。

##### 追加操作优化

Redis使用内存预分配的策略来优化字符串追加，这样可以加快追加操作的速度，并降低内存分配的次数，代价是多占用了一些内存，而且这些内存不会被主动释放。

在目前版本的 Redis 中， `SDS_MAX_PREALLOC` 的值为 `1024 * 1024` ， 也就是说， 当大小小于 `1MB` 的字符串执行追加操作时， `sdsMakeRoomFor` 就为它们分配多于所需大小一倍的空间； 当字符串的大小大于 `1MB` ， 那么 `sdsMakeRoomFor` 就为它们额外多分配 `1MB` 的空间。



### 双端链表

- Redis 实现了自己的双端链表结构。
- 双端链表主要有两个作用：
  - 作为 Redis 列表类型的底层实现之一；
  - 作为通用数据结构，被其他功能模块所使用；
- 双端链表及其节点的性能特性如下：
  - 节点带有前驱和后继指针，访问前驱节点和后继节点的复杂度为 O(1)O(1) ，并且对链表的迭代可以在从表头到表尾和从表尾到表头两个方向进行；
  - 链表带有指向表头和表尾的指针，因此对表头和表尾进行处理的复杂度为 O(1)O(1) ；
  - 链表带有记录节点数量的属性，所以可以在 O(1)O(1) 复杂度内返回链表的节点数量（长度）；



### 字典

#### 应用

- 数据库的键空间

  redis整个数据库的k-v都是用的字典

- 用作Hash类型的底层实现之一

  hash类型底层实现之一是字典，另外是ziplist

  

#### 实现



#### 添加数据



#### Rehash过程



### 跳表



## 内存映射数据结构



## 基础数据类型

